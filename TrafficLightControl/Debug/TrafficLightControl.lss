
TrafficLightControl.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005ac  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000620  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00800060  00800060  00000620  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000620  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000650  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000138  00000000  00000000  0000068c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000149c  00000000  00000000  000007c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000086b  00000000  00000000  00001c60  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b5d  00000000  00000000  000024cb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001dc  00000000  00000000  00003028  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000056a  00000000  00000000  00003204  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000004c9  00000000  00000000  0000376e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000c8  00000000  00000000  00003c37  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 83 01 	jmp	0x306	; 0x306 <__vector_1>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__vector_11>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	a4 36       	cpi	r26, 0x64	; 100
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 d6 01 	call	0x3ac	; 0x3ac <main>
  74:	0c 94 d4 02 	jmp	0x5a8	; 0x5a8 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <APP_init>:
//flag used for checking if traffic light was red or not
uint8 trafRedLed = 0;

void APP_init(void){
	//pins setup
	LedInit(trafficRed);		//initialize led connected in port A pin 0
  7c:	60 e0       	ldi	r22, 0x00	; 0
  7e:	80 e0       	ldi	r24, 0x00	; 0
  80:	0e 94 ca 01 	call	0x394	; 0x394 <LedInit>
	LedInit(trafficYellow);		//initialize led connected in port A pin 1
  84:	61 e0       	ldi	r22, 0x01	; 1
  86:	80 e0       	ldi	r24, 0x00	; 0
  88:	0e 94 ca 01 	call	0x394	; 0x394 <LedInit>
	LedInit(trafficGreen);		//initialize led connected in port A pin 2
  8c:	62 e0       	ldi	r22, 0x02	; 2
  8e:	80 e0       	ldi	r24, 0x00	; 0
  90:	0e 94 ca 01 	call	0x394	; 0x394 <LedInit>
	LedInit(pedestrianRed);		//initialize led connected in port B pin 0
  94:	60 e0       	ldi	r22, 0x00	; 0
  96:	81 e0       	ldi	r24, 0x01	; 1
  98:	0e 94 ca 01 	call	0x394	; 0x394 <LedInit>
	LedInit(pedestrianYellow);		//initialize led connected in port B pin 1
  9c:	61 e0       	ldi	r22, 0x01	; 1
  9e:	81 e0       	ldi	r24, 0x01	; 1
  a0:	0e 94 ca 01 	call	0x394	; 0x394 <LedInit>
	LedInit(pedestrianGreen);		//initialize led connected in port B pin 2
  a4:	62 e0       	ldi	r22, 0x02	; 2
  a6:	81 e0       	ldi	r24, 0x01	; 1
  a8:	0e 94 ca 01 	call	0x394	; 0x394 <LedInit>
	BUTTON_init(pedestrianButton);	//initialize button connected in port D pin 2
  ac:	62 e0       	ldi	r22, 0x02	; 2
  ae:	83 e0       	ldi	r24, 0x03	; 3
  b0:	0e 94 c6 01 	call	0x38c	; 0x38c <BUTTON_init>
	//drivers initialization
	int0Init();				//initialize external interrupt 0
  b4:	0e 94 b7 02 	call	0x56e	; 0x56e <int0Init>
	timer0Init();			//initialize timer 0
  b8:	0e 94 c2 02 	call	0x584	; 0x584 <timer0Init>
  bc:	08 95       	ret

000000be <APP_start>:
}

void APP_start(void){
	while(1){
		switch(mode){
  be:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <mode>
  c2:	81 30       	cpi	r24, 0x01	; 1
  c4:	09 f4       	brne	.+2      	; 0xc8 <APP_start+0xa>
  c6:	93 c0       	rjmp	.+294    	; 0x1ee <APP_start+0x130>
  c8:	20 f0       	brcs	.+8      	; 0xd2 <APP_start+0x14>
  ca:	82 30       	cpi	r24, 0x02	; 2
  cc:	09 f4       	brne	.+2      	; 0xd0 <APP_start+0x12>
  ce:	e3 c0       	rjmp	.+454    	; 0x296 <APP_start+0x1d8>
  d0:	f6 cf       	rjmp	.-20     	; 0xbe <APP_start>
			case normalMode:
				if(overFlowCounter<=20){
  d2:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <overFlowCounter>
  d6:	85 31       	cpi	r24, 0x15	; 21
  d8:	d8 f4       	brcc	.+54     	; 0x110 <APP_start+0x52>
					//turn on the traffic green light and the pedestrian red light  for 5 sec and reset the traffic red light flag
					trafRedLed=0;
  da:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
					LedOn(pedestrianRed);
  de:	60 e0       	ldi	r22, 0x00	; 0
  e0:	81 e0       	ldi	r24, 0x01	; 1
  e2:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
					LedOn(trafficGreen);
  e6:	62 e0       	ldi	r22, 0x02	; 2
  e8:	80 e0       	ldi	r24, 0x00	; 0
  ea:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
					LedOff(trafficRed);
  ee:	60 e0       	ldi	r22, 0x00	; 0
  f0:	80 e0       	ldi	r24, 0x00	; 0
  f2:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(trafficYellow);
  f6:	61 e0       	ldi	r22, 0x01	; 1
  f8:	80 e0       	ldi	r24, 0x00	; 0
  fa:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(pedestrianYellow);
  fe:	61 e0       	ldi	r22, 0x01	; 1
 100:	81 e0       	ldi	r24, 0x01	; 1
 102:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(pedestrianGreen);
 106:	62 e0       	ldi	r22, 0x02	; 2
 108:	81 e0       	ldi	r24, 0x01	; 1
 10a:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
 10e:	d7 cf       	rjmp	.-82     	; 0xbe <APP_start>
				}else if(overFlowCounter > 20 && overFlowCounter <= 40){
 110:	9b ee       	ldi	r25, 0xEB	; 235
 112:	98 0f       	add	r25, r24
 114:	94 31       	cpi	r25, 0x14	; 20
 116:	20 f5       	brcc	.+72     	; 0x160 <APP_start+0xa2>
					//blink the yellow traffic light for 5 sec and keep the pedestrian light red and reset the red traffic light flag
					trafRedLed=0;
 118:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
					(yellowLedState)?LedOn(trafficYellow):LedOff(trafficYellow);
 11c:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <yellowLedState>
 120:	88 23       	and	r24, r24
 122:	29 f0       	breq	.+10     	; 0x12e <APP_start+0x70>
 124:	61 e0       	ldi	r22, 0x01	; 1
 126:	80 e0       	ldi	r24, 0x00	; 0
 128:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
 12c:	04 c0       	rjmp	.+8      	; 0x136 <APP_start+0x78>
 12e:	61 e0       	ldi	r22, 0x01	; 1
 130:	80 e0       	ldi	r24, 0x00	; 0
 132:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOn(pedestrianRed);
 136:	60 e0       	ldi	r22, 0x00	; 0
 138:	81 e0       	ldi	r24, 0x01	; 1
 13a:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
					LedOff(trafficRed);
 13e:	60 e0       	ldi	r22, 0x00	; 0
 140:	80 e0       	ldi	r24, 0x00	; 0
 142:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(trafficGreen);
 146:	62 e0       	ldi	r22, 0x02	; 2
 148:	80 e0       	ldi	r24, 0x00	; 0
 14a:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(pedestrianYellow);
 14e:	61 e0       	ldi	r22, 0x01	; 1
 150:	81 e0       	ldi	r24, 0x01	; 1
 152:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(pedestrianGreen);
 156:	62 e0       	ldi	r22, 0x02	; 2
 158:	81 e0       	ldi	r24, 0x01	; 1
 15a:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
 15e:	af cf       	rjmp	.-162    	; 0xbe <APP_start>
				}else if(overFlowCounter > 40 && overFlowCounter <= 60){
 160:	97 ed       	ldi	r25, 0xD7	; 215
 162:	98 0f       	add	r25, r24
 164:	94 31       	cpi	r25, 0x14	; 20
 166:	e0 f4       	brcc	.+56     	; 0x1a0 <APP_start+0xe2>
					//turn traffic red on and turn pedestrian green on for 5 sec and set the red traffic light flag
					trafRedLed=1;
 168:	81 e0       	ldi	r24, 0x01	; 1
 16a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
					LedOn(trafficRed);
 16e:	60 e0       	ldi	r22, 0x00	; 0
 170:	80 e0       	ldi	r24, 0x00	; 0
 172:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
					LedOn(pedestrianGreen);
 176:	62 e0       	ldi	r22, 0x02	; 2
 178:	81 e0       	ldi	r24, 0x01	; 1
 17a:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
					LedOff(trafficYellow);
 17e:	61 e0       	ldi	r22, 0x01	; 1
 180:	80 e0       	ldi	r24, 0x00	; 0
 182:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(trafficGreen);
 186:	62 e0       	ldi	r22, 0x02	; 2
 188:	80 e0       	ldi	r24, 0x00	; 0
 18a:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(pedestrianYellow);
 18e:	61 e0       	ldi	r22, 0x01	; 1
 190:	81 e0       	ldi	r24, 0x01	; 1
 192:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(pedestrianRed);
 196:	60 e0       	ldi	r22, 0x00	; 0
 198:	81 e0       	ldi	r24, 0x01	; 1
 19a:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
 19e:	8f cf       	rjmp	.-226    	; 0xbe <APP_start>
				}else if(overFlowCounter > 60 ){
 1a0:	8d 33       	cpi	r24, 0x3D	; 61
 1a2:	08 f4       	brcc	.+2      	; 0x1a6 <APP_start+0xe8>
 1a4:	8c cf       	rjmp	.-232    	; 0xbe <APP_start>
					//blink the yellow traffic light for 5 sec and keep the pedestrian light green and reset the red traffic light flag
					trafRedLed=0;
 1a6:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
					(yellowLedState)?LedOn(trafficYellow):LedOff(trafficYellow);
 1aa:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <yellowLedState>
 1ae:	88 23       	and	r24, r24
 1b0:	29 f0       	breq	.+10     	; 0x1bc <APP_start+0xfe>
 1b2:	61 e0       	ldi	r22, 0x01	; 1
 1b4:	80 e0       	ldi	r24, 0x00	; 0
 1b6:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
 1ba:	04 c0       	rjmp	.+8      	; 0x1c4 <APP_start+0x106>
 1bc:	61 e0       	ldi	r22, 0x01	; 1
 1be:	80 e0       	ldi	r24, 0x00	; 0
 1c0:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOn(pedestrianGreen);
 1c4:	62 e0       	ldi	r22, 0x02	; 2
 1c6:	81 e0       	ldi	r24, 0x01	; 1
 1c8:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
					LedOff(trafficRed);
 1cc:	60 e0       	ldi	r22, 0x00	; 0
 1ce:	80 e0       	ldi	r24, 0x00	; 0
 1d0:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(trafficGreen);
 1d4:	62 e0       	ldi	r22, 0x02	; 2
 1d6:	80 e0       	ldi	r24, 0x00	; 0
 1d8:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(pedestrianYellow);
 1dc:	61 e0       	ldi	r22, 0x01	; 1
 1de:	81 e0       	ldi	r24, 0x01	; 1
 1e0:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(pedestrianRed);
 1e4:	60 e0       	ldi	r22, 0x00	; 0
 1e6:	81 e0       	ldi	r24, 0x01	; 1
 1e8:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
 1ec:	68 cf       	rjmp	.-304    	; 0xbe <APP_start>
				}
				break;
			case pedestrianMode:
				if(overFlowCounter<=20){
 1ee:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <overFlowCounter>
 1f2:	85 31       	cpi	r24, 0x15	; 21
 1f4:	c8 f4       	brcc	.+50     	; 0x228 <APP_start+0x16a>
					//turn red traffic led on and green pedestrian led on
					LedOn(pedestrianGreen);
 1f6:	62 e0       	ldi	r22, 0x02	; 2
 1f8:	81 e0       	ldi	r24, 0x01	; 1
 1fa:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
					LedOn(trafficRed);
 1fe:	60 e0       	ldi	r22, 0x00	; 0
 200:	80 e0       	ldi	r24, 0x00	; 0
 202:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
					LedOff(pedestrianRed);
 206:	60 e0       	ldi	r22, 0x00	; 0
 208:	81 e0       	ldi	r24, 0x01	; 1
 20a:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(pedestrianYellow);
 20e:	61 e0       	ldi	r22, 0x01	; 1
 210:	81 e0       	ldi	r24, 0x01	; 1
 212:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(trafficYellow);
 216:	61 e0       	ldi	r22, 0x01	; 1
 218:	80 e0       	ldi	r24, 0x00	; 0
 21a:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(trafficGreen);
 21e:	62 e0       	ldi	r22, 0x02	; 2
 220:	80 e0       	ldi	r24, 0x00	; 0
 222:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
 226:	4b cf       	rjmp	.-362    	; 0xbe <APP_start>
				}else if(overFlowCounter > 20 && overFlowCounter <= 40){
 228:	9b ee       	ldi	r25, 0xEB	; 235
 22a:	98 0f       	add	r25, r24
 22c:	94 31       	cpi	r25, 0x14	; 20
 22e:	58 f5       	brcc	.+86     	; 0x286 <APP_start+0x1c8>
					//blink the two yellow leds for 5 sec while keeping green pedestrian led on
					(yellowLedState)?LedOn(trafficYellow):LedOff(trafficYellow);
 230:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <yellowLedState>
 234:	88 23       	and	r24, r24
 236:	29 f0       	breq	.+10     	; 0x242 <APP_start+0x184>
 238:	61 e0       	ldi	r22, 0x01	; 1
 23a:	80 e0       	ldi	r24, 0x00	; 0
 23c:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
 240:	04 c0       	rjmp	.+8      	; 0x24a <APP_start+0x18c>
 242:	61 e0       	ldi	r22, 0x01	; 1
 244:	80 e0       	ldi	r24, 0x00	; 0
 246:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					(yellowLedState)?LedOn(pedestrianYellow):LedOff(pedestrianYellow);
 24a:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <yellowLedState>
 24e:	88 23       	and	r24, r24
 250:	29 f0       	breq	.+10     	; 0x25c <APP_start+0x19e>
 252:	61 e0       	ldi	r22, 0x01	; 1
 254:	81 e0       	ldi	r24, 0x01	; 1
 256:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
 25a:	04 c0       	rjmp	.+8      	; 0x264 <APP_start+0x1a6>
 25c:	61 e0       	ldi	r22, 0x01	; 1
 25e:	81 e0       	ldi	r24, 0x01	; 1
 260:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOn(pedestrianGreen);
 264:	62 e0       	ldi	r22, 0x02	; 2
 266:	81 e0       	ldi	r24, 0x01	; 1
 268:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
					LedOff(trafficRed);
 26c:	60 e0       	ldi	r22, 0x00	; 0
 26e:	80 e0       	ldi	r24, 0x00	; 0
 270:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(trafficGreen);
 274:	62 e0       	ldi	r22, 0x02	; 2
 276:	80 e0       	ldi	r24, 0x00	; 0
 278:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(pedestrianRed);
 27c:	60 e0       	ldi	r22, 0x00	; 0
 27e:	81 e0       	ldi	r24, 0x01	; 1
 280:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
 284:	1c cf       	rjmp	.-456    	; 0xbe <APP_start>
				}else if(overFlowCounter > 40){
 286:	89 32       	cpi	r24, 0x29	; 41
 288:	08 f4       	brcc	.+2      	; 0x28c <APP_start+0x1ce>
 28a:	19 cf       	rjmp	.-462    	; 0xbe <APP_start>
					//at the end of halt mode return to pedestrian mode and reset counter
					overFlowCounter = 0;
 28c:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <overFlowCounter>
					mode = normalMode;
 290:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <mode>
 294:	14 cf       	rjmp	.-472    	; 0xbe <APP_start>
				}
				break;
			case haltMode:
				if(overFlowCounter<=20){
 296:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <overFlowCounter>
 29a:	85 31       	cpi	r24, 0x15	; 21
 29c:	58 f5       	brcc	.+86     	; 0x2f4 <APP_start+0x236>
					//turn on pedestrian red led and blink both pedestrian and traffic yellow leds
					(yellowLedState)?LedOn(trafficYellow):LedOff(trafficYellow);
 29e:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <yellowLedState>
 2a2:	88 23       	and	r24, r24
 2a4:	29 f0       	breq	.+10     	; 0x2b0 <APP_start+0x1f2>
 2a6:	61 e0       	ldi	r22, 0x01	; 1
 2a8:	80 e0       	ldi	r24, 0x00	; 0
 2aa:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
 2ae:	04 c0       	rjmp	.+8      	; 0x2b8 <APP_start+0x1fa>
 2b0:	61 e0       	ldi	r22, 0x01	; 1
 2b2:	80 e0       	ldi	r24, 0x00	; 0
 2b4:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					(yellowLedState)?LedOn(pedestrianYellow):LedOff(pedestrianYellow);
 2b8:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <yellowLedState>
 2bc:	88 23       	and	r24, r24
 2be:	29 f0       	breq	.+10     	; 0x2ca <APP_start+0x20c>
 2c0:	61 e0       	ldi	r22, 0x01	; 1
 2c2:	81 e0       	ldi	r24, 0x01	; 1
 2c4:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
 2c8:	04 c0       	rjmp	.+8      	; 0x2d2 <APP_start+0x214>
 2ca:	61 e0       	ldi	r22, 0x01	; 1
 2cc:	81 e0       	ldi	r24, 0x01	; 1
 2ce:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOn(pedestrianRed);
 2d2:	60 e0       	ldi	r22, 0x00	; 0
 2d4:	81 e0       	ldi	r24, 0x01	; 1
 2d6:	0e 94 ce 01 	call	0x39c	; 0x39c <LedOn>
					LedOff(pedestrianGreen);
 2da:	62 e0       	ldi	r22, 0x02	; 2
 2dc:	81 e0       	ldi	r24, 0x01	; 1
 2de:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(trafficRed);
 2e2:	60 e0       	ldi	r22, 0x00	; 0
 2e4:	80 e0       	ldi	r24, 0x00	; 0
 2e6:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
					LedOff(trafficGreen);
 2ea:	62 e0       	ldi	r22, 0x02	; 2
 2ec:	80 e0       	ldi	r24, 0x00	; 0
 2ee:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LedOff>
 2f2:	e5 ce       	rjmp	.-566    	; 0xbe <APP_start>
				}else if(overFlowCounter > 20){
 2f4:	85 31       	cpi	r24, 0x15	; 21
 2f6:	08 f4       	brcc	.+2      	; 0x2fa <APP_start+0x23c>
 2f8:	e2 ce       	rjmp	.-572    	; 0xbe <APP_start>
					//at the end of halt mode return to pedestrian mode and reset counter
					overFlowCounter = 0;
 2fa:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <overFlowCounter>
					mode = pedestrianMode;
 2fe:	81 e0       	ldi	r24, 0x01	; 1
 300:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <mode>
 304:	dc ce       	rjmp	.-584    	; 0xbe <APP_start>

00000306 <__vector_1>:
		}
	}
}

//interrupt service routine for button pressing
ISR(EXT_INT_0){
 306:	1f 92       	push	r1
 308:	0f 92       	push	r0
 30a:	0f b6       	in	r0, 0x3f	; 63
 30c:	0f 92       	push	r0
 30e:	11 24       	eor	r1, r1
 310:	8f 93       	push	r24
 312:	9f 93       	push	r25
	if((mode == normalMode) && trafRedLed){
 314:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <mode>
 318:	81 11       	cpse	r24, r1
 31a:	0a c0       	rjmp	.+20     	; 0x330 <__vector_1+0x2a>
 31c:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 320:	99 23       	and	r25, r25
 322:	31 f0       	breq	.+12     	; 0x330 <__vector_1+0x2a>
		mode = pedestrianMode;
 324:	81 e0       	ldi	r24, 0x01	; 1
 326:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <mode>
		overFlowCounter=0;
 32a:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <overFlowCounter>
 32e:	07 c0       	rjmp	.+14     	; 0x33e <__vector_1+0x38>
	}else if(mode == normalMode){
 330:	81 11       	cpse	r24, r1
 332:	05 c0       	rjmp	.+10     	; 0x33e <__vector_1+0x38>
		mode = haltMode;
 334:	82 e0       	ldi	r24, 0x02	; 2
 336:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <mode>
		overFlowCounter=0;
 33a:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <overFlowCounter>
	}
}
 33e:	9f 91       	pop	r25
 340:	8f 91       	pop	r24
 342:	0f 90       	pop	r0
 344:	0f be       	out	0x3f, r0	; 63
 346:	0f 90       	pop	r0
 348:	1f 90       	pop	r1
 34a:	18 95       	reti

0000034c <__vector_11>:

//interrupt service routine for timer counting
ISR(Timer_0_OVF){
 34c:	1f 92       	push	r1
 34e:	0f 92       	push	r0
 350:	0f b6       	in	r0, 0x3f	; 63
 352:	0f 92       	push	r0
 354:	11 24       	eor	r1, r1
 356:	2f 93       	push	r18
 358:	8f 93       	push	r24
 35a:	9f 93       	push	r25
	overFlowCounter++;	//increment overflow counter
 35c:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <overFlowCounter>
 360:	8f 5f       	subi	r24, 0xFF	; 255
 362:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <overFlowCounter>
	yellowLedState = !yellowLedState;
 366:	91 e0       	ldi	r25, 0x01	; 1
 368:	20 91 61 00 	lds	r18, 0x0061	; 0x800061 <yellowLedState>
 36c:	21 11       	cpse	r18, r1
 36e:	90 e0       	ldi	r25, 0x00	; 0
 370:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <yellowLedState>
	if(overFlowCounter > 80){
 374:	81 35       	cpi	r24, 0x51	; 81
 376:	10 f0       	brcs	.+4      	; 0x37c <__vector_11+0x30>
		overFlowCounter=0;	//reset timer counter
 378:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <overFlowCounter>
	}
 37c:	9f 91       	pop	r25
 37e:	8f 91       	pop	r24
 380:	2f 91       	pop	r18
 382:	0f 90       	pop	r0
 384:	0f be       	out	0x3f, r0	; 63
 386:	0f 90       	pop	r0
 388:	1f 90       	pop	r1
 38a:	18 95       	reti

0000038c <BUTTON_init>:

#include "button.h"


void BUTTON_init(ports_t buttonPort,pins_t buttonPin){
	DIO_init(buttonPort,buttonPin,INPUT);
 38c:	40 e0       	ldi	r20, 0x00	; 0
 38e:	0e 94 dd 01 	call	0x3ba	; 0x3ba <DIO_init>
 392:	08 95       	ret

00000394 <LedInit>:
 *  Author: M.Eltokhy
 */ 
#include "led.h"

void LedInit(ports_t ledPort,pins_t ledPin){
	DIO_init(ledPort,ledPin,OUTPUT);
 394:	41 e0       	ldi	r20, 0x01	; 1
 396:	0e 94 dd 01 	call	0x3ba	; 0x3ba <DIO_init>
 39a:	08 95       	ret

0000039c <LedOn>:
}

void LedOn(ports_t ledPort,pins_t ledPin){
	DIO_write(ledPort,ledPin,HIGH);
 39c:	41 e0       	ldi	r20, 0x01	; 1
 39e:	0e 94 4a 02 	call	0x494	; 0x494 <DIO_write>
 3a2:	08 95       	ret

000003a4 <LedOff>:
}

void LedOff(ports_t ledPort,pins_t ledPin){
	DIO_write(ledPort,ledPin,LOW);
 3a4:	40 e0       	ldi	r20, 0x00	; 0
 3a6:	0e 94 4a 02 	call	0x494	; 0x494 <DIO_write>
 3aa:	08 95       	ret

000003ac <main>:
		if((!(counter%4)) && counter){
			DIO_toggle(PORT_A,7);
		}
	}
	*/
	APP_init();
 3ac:	0e 94 3e 00 	call	0x7c	; 0x7c <APP_init>
	APP_start();
 3b0:	0e 94 5f 00 	call	0xbe	; 0xbe <APP_start>
	return 0;
}
 3b4:	80 e0       	ldi	r24, 0x00	; 0
 3b6:	90 e0       	ldi	r25, 0x00	; 0
 3b8:	08 95       	ret

000003ba <DIO_init>:
#include "dio.h"
//global variables

//functions definitions
void DIO_init(ports_t portNumber,pins_t pinNumber,direction_t direction){
	switch(portNumber){
 3ba:	81 30       	cpi	r24, 0x01	; 1
 3bc:	01 f1       	breq	.+64     	; 0x3fe <DIO_init+0x44>
 3be:	30 f0       	brcs	.+12     	; 0x3cc <DIO_init+0x12>
 3c0:	82 30       	cpi	r24, 0x02	; 2
 3c2:	b1 f1       	breq	.+108    	; 0x430 <__EEPROM_REGION_LENGTH__+0x30>
 3c4:	83 30       	cpi	r24, 0x03	; 3
 3c6:	09 f4       	brne	.+2      	; 0x3ca <DIO_init+0x10>
 3c8:	4c c0       	rjmp	.+152    	; 0x462 <__EEPROM_REGION_LENGTH__+0x62>
 3ca:	08 95       	ret
		case PORT_A:
			(direction)?setBit(DDRA,pinNumber):clearBit(DDRA,pinNumber);	//SETTING PORTA DIRECTION
 3cc:	44 23       	and	r20, r20
 3ce:	59 f0       	breq	.+22     	; 0x3e6 <DIO_init+0x2c>
 3d0:	2a b3       	in	r18, 0x1a	; 26
 3d2:	81 e0       	ldi	r24, 0x01	; 1
 3d4:	90 e0       	ldi	r25, 0x00	; 0
 3d6:	02 c0       	rjmp	.+4      	; 0x3dc <DIO_init+0x22>
 3d8:	88 0f       	add	r24, r24
 3da:	99 1f       	adc	r25, r25
 3dc:	6a 95       	dec	r22
 3de:	e2 f7       	brpl	.-8      	; 0x3d8 <DIO_init+0x1e>
 3e0:	82 2b       	or	r24, r18
 3e2:	8a bb       	out	0x1a, r24	; 26
 3e4:	08 95       	ret
 3e6:	2a b3       	in	r18, 0x1a	; 26
 3e8:	81 e0       	ldi	r24, 0x01	; 1
 3ea:	90 e0       	ldi	r25, 0x00	; 0
 3ec:	02 c0       	rjmp	.+4      	; 0x3f2 <DIO_init+0x38>
 3ee:	88 0f       	add	r24, r24
 3f0:	99 1f       	adc	r25, r25
 3f2:	6a 95       	dec	r22
 3f4:	e2 f7       	brpl	.-8      	; 0x3ee <DIO_init+0x34>
 3f6:	80 95       	com	r24
 3f8:	82 23       	and	r24, r18
 3fa:	8a bb       	out	0x1a, r24	; 26
 3fc:	08 95       	ret
			break;
		case PORT_B:
			(direction)?setBit(DDRB,pinNumber):clearBit(DDRB,pinNumber);	//SETTING PORTB DIRECTION
 3fe:	44 23       	and	r20, r20
 400:	59 f0       	breq	.+22     	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
 402:	27 b3       	in	r18, 0x17	; 23
 404:	81 e0       	ldi	r24, 0x01	; 1
 406:	90 e0       	ldi	r25, 0x00	; 0
 408:	02 c0       	rjmp	.+4      	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
 40a:	88 0f       	add	r24, r24
 40c:	99 1f       	adc	r25, r25
 40e:	6a 95       	dec	r22
 410:	e2 f7       	brpl	.-8      	; 0x40a <__EEPROM_REGION_LENGTH__+0xa>
 412:	82 2b       	or	r24, r18
 414:	87 bb       	out	0x17, r24	; 23
 416:	08 95       	ret
 418:	27 b3       	in	r18, 0x17	; 23
 41a:	81 e0       	ldi	r24, 0x01	; 1
 41c:	90 e0       	ldi	r25, 0x00	; 0
 41e:	02 c0       	rjmp	.+4      	; 0x424 <__EEPROM_REGION_LENGTH__+0x24>
 420:	88 0f       	add	r24, r24
 422:	99 1f       	adc	r25, r25
 424:	6a 95       	dec	r22
 426:	e2 f7       	brpl	.-8      	; 0x420 <__EEPROM_REGION_LENGTH__+0x20>
 428:	80 95       	com	r24
 42a:	82 23       	and	r24, r18
 42c:	87 bb       	out	0x17, r24	; 23
 42e:	08 95       	ret
			break;
		case PORT_C:
			(direction)?setBit(DDRC,pinNumber):clearBit(DDRC,pinNumber);	//SETTING PORTC DIRECTION
 430:	44 23       	and	r20, r20
 432:	59 f0       	breq	.+22     	; 0x44a <__EEPROM_REGION_LENGTH__+0x4a>
 434:	24 b3       	in	r18, 0x14	; 20
 436:	81 e0       	ldi	r24, 0x01	; 1
 438:	90 e0       	ldi	r25, 0x00	; 0
 43a:	02 c0       	rjmp	.+4      	; 0x440 <__EEPROM_REGION_LENGTH__+0x40>
 43c:	88 0f       	add	r24, r24
 43e:	99 1f       	adc	r25, r25
 440:	6a 95       	dec	r22
 442:	e2 f7       	brpl	.-8      	; 0x43c <__EEPROM_REGION_LENGTH__+0x3c>
 444:	82 2b       	or	r24, r18
 446:	84 bb       	out	0x14, r24	; 20
 448:	08 95       	ret
 44a:	24 b3       	in	r18, 0x14	; 20
 44c:	81 e0       	ldi	r24, 0x01	; 1
 44e:	90 e0       	ldi	r25, 0x00	; 0
 450:	02 c0       	rjmp	.+4      	; 0x456 <__EEPROM_REGION_LENGTH__+0x56>
 452:	88 0f       	add	r24, r24
 454:	99 1f       	adc	r25, r25
 456:	6a 95       	dec	r22
 458:	e2 f7       	brpl	.-8      	; 0x452 <__EEPROM_REGION_LENGTH__+0x52>
 45a:	80 95       	com	r24
 45c:	82 23       	and	r24, r18
 45e:	84 bb       	out	0x14, r24	; 20
 460:	08 95       	ret
			break;
		case PORT_D:
			(direction)?setBit(DDRD,pinNumber):clearBit(DDRD,pinNumber);	//SETTING PORTD DIRECTION
 462:	44 23       	and	r20, r20
 464:	59 f0       	breq	.+22     	; 0x47c <__EEPROM_REGION_LENGTH__+0x7c>
 466:	21 b3       	in	r18, 0x11	; 17
 468:	81 e0       	ldi	r24, 0x01	; 1
 46a:	90 e0       	ldi	r25, 0x00	; 0
 46c:	02 c0       	rjmp	.+4      	; 0x472 <__EEPROM_REGION_LENGTH__+0x72>
 46e:	88 0f       	add	r24, r24
 470:	99 1f       	adc	r25, r25
 472:	6a 95       	dec	r22
 474:	e2 f7       	brpl	.-8      	; 0x46e <__EEPROM_REGION_LENGTH__+0x6e>
 476:	82 2b       	or	r24, r18
 478:	81 bb       	out	0x11, r24	; 17
 47a:	08 95       	ret
 47c:	21 b3       	in	r18, 0x11	; 17
 47e:	81 e0       	ldi	r24, 0x01	; 1
 480:	90 e0       	ldi	r25, 0x00	; 0
 482:	02 c0       	rjmp	.+4      	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
 484:	88 0f       	add	r24, r24
 486:	99 1f       	adc	r25, r25
 488:	6a 95       	dec	r22
 48a:	e2 f7       	brpl	.-8      	; 0x484 <__EEPROM_REGION_LENGTH__+0x84>
 48c:	80 95       	com	r24
 48e:	82 23       	and	r24, r18
 490:	81 bb       	out	0x11, r24	; 17
 492:	08 95       	ret

00000494 <DIO_write>:
			break;
	}
}

void DIO_write(ports_t portNumber,pins_t pinNumber,state_t state){
	switch(portNumber){
 494:	81 30       	cpi	r24, 0x01	; 1
 496:	01 f1       	breq	.+64     	; 0x4d8 <DIO_write+0x44>
 498:	30 f0       	brcs	.+12     	; 0x4a6 <DIO_write+0x12>
 49a:	82 30       	cpi	r24, 0x02	; 2
 49c:	b1 f1       	breq	.+108    	; 0x50a <DIO_write+0x76>
 49e:	83 30       	cpi	r24, 0x03	; 3
 4a0:	09 f4       	brne	.+2      	; 0x4a4 <DIO_write+0x10>
 4a2:	4c c0       	rjmp	.+152    	; 0x53c <DIO_write+0xa8>
 4a4:	08 95       	ret
		case PORT_A:
			(state)?setBit(PORTA,pinNumber):clearBit(PORTA,pinNumber);
 4a6:	44 23       	and	r20, r20
 4a8:	59 f0       	breq	.+22     	; 0x4c0 <DIO_write+0x2c>
 4aa:	2b b3       	in	r18, 0x1b	; 27
 4ac:	81 e0       	ldi	r24, 0x01	; 1
 4ae:	90 e0       	ldi	r25, 0x00	; 0
 4b0:	02 c0       	rjmp	.+4      	; 0x4b6 <DIO_write+0x22>
 4b2:	88 0f       	add	r24, r24
 4b4:	99 1f       	adc	r25, r25
 4b6:	6a 95       	dec	r22
 4b8:	e2 f7       	brpl	.-8      	; 0x4b2 <DIO_write+0x1e>
 4ba:	82 2b       	or	r24, r18
 4bc:	8b bb       	out	0x1b, r24	; 27
 4be:	08 95       	ret
 4c0:	2b b3       	in	r18, 0x1b	; 27
 4c2:	81 e0       	ldi	r24, 0x01	; 1
 4c4:	90 e0       	ldi	r25, 0x00	; 0
 4c6:	02 c0       	rjmp	.+4      	; 0x4cc <DIO_write+0x38>
 4c8:	88 0f       	add	r24, r24
 4ca:	99 1f       	adc	r25, r25
 4cc:	6a 95       	dec	r22
 4ce:	e2 f7       	brpl	.-8      	; 0x4c8 <DIO_write+0x34>
 4d0:	80 95       	com	r24
 4d2:	82 23       	and	r24, r18
 4d4:	8b bb       	out	0x1b, r24	; 27
 4d6:	08 95       	ret
			break;
		case PORT_B:
			(state)?setBit(PORTB,pinNumber):clearBit(PORTB,pinNumber);
 4d8:	44 23       	and	r20, r20
 4da:	59 f0       	breq	.+22     	; 0x4f2 <DIO_write+0x5e>
 4dc:	28 b3       	in	r18, 0x18	; 24
 4de:	81 e0       	ldi	r24, 0x01	; 1
 4e0:	90 e0       	ldi	r25, 0x00	; 0
 4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_write+0x54>
 4e4:	88 0f       	add	r24, r24
 4e6:	99 1f       	adc	r25, r25
 4e8:	6a 95       	dec	r22
 4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_write+0x50>
 4ec:	82 2b       	or	r24, r18
 4ee:	88 bb       	out	0x18, r24	; 24
 4f0:	08 95       	ret
 4f2:	28 b3       	in	r18, 0x18	; 24
 4f4:	81 e0       	ldi	r24, 0x01	; 1
 4f6:	90 e0       	ldi	r25, 0x00	; 0
 4f8:	02 c0       	rjmp	.+4      	; 0x4fe <DIO_write+0x6a>
 4fa:	88 0f       	add	r24, r24
 4fc:	99 1f       	adc	r25, r25
 4fe:	6a 95       	dec	r22
 500:	e2 f7       	brpl	.-8      	; 0x4fa <DIO_write+0x66>
 502:	80 95       	com	r24
 504:	82 23       	and	r24, r18
 506:	88 bb       	out	0x18, r24	; 24
 508:	08 95       	ret
			break;
		case PORT_C:
			(state)?setBit(PORTC,pinNumber):clearBit(PORTC,pinNumber);
 50a:	44 23       	and	r20, r20
 50c:	59 f0       	breq	.+22     	; 0x524 <DIO_write+0x90>
 50e:	25 b3       	in	r18, 0x15	; 21
 510:	81 e0       	ldi	r24, 0x01	; 1
 512:	90 e0       	ldi	r25, 0x00	; 0
 514:	02 c0       	rjmp	.+4      	; 0x51a <DIO_write+0x86>
 516:	88 0f       	add	r24, r24
 518:	99 1f       	adc	r25, r25
 51a:	6a 95       	dec	r22
 51c:	e2 f7       	brpl	.-8      	; 0x516 <DIO_write+0x82>
 51e:	82 2b       	or	r24, r18
 520:	85 bb       	out	0x15, r24	; 21
 522:	08 95       	ret
 524:	25 b3       	in	r18, 0x15	; 21
 526:	81 e0       	ldi	r24, 0x01	; 1
 528:	90 e0       	ldi	r25, 0x00	; 0
 52a:	02 c0       	rjmp	.+4      	; 0x530 <DIO_write+0x9c>
 52c:	88 0f       	add	r24, r24
 52e:	99 1f       	adc	r25, r25
 530:	6a 95       	dec	r22
 532:	e2 f7       	brpl	.-8      	; 0x52c <DIO_write+0x98>
 534:	80 95       	com	r24
 536:	82 23       	and	r24, r18
 538:	85 bb       	out	0x15, r24	; 21
 53a:	08 95       	ret
			break;
		case PORT_D:
			(state)?setBit(PORTD,pinNumber):clearBit(PORTD,pinNumber);
 53c:	44 23       	and	r20, r20
 53e:	59 f0       	breq	.+22     	; 0x556 <DIO_write+0xc2>
 540:	22 b3       	in	r18, 0x12	; 18
 542:	81 e0       	ldi	r24, 0x01	; 1
 544:	90 e0       	ldi	r25, 0x00	; 0
 546:	02 c0       	rjmp	.+4      	; 0x54c <DIO_write+0xb8>
 548:	88 0f       	add	r24, r24
 54a:	99 1f       	adc	r25, r25
 54c:	6a 95       	dec	r22
 54e:	e2 f7       	brpl	.-8      	; 0x548 <DIO_write+0xb4>
 550:	82 2b       	or	r24, r18
 552:	82 bb       	out	0x12, r24	; 18
 554:	08 95       	ret
 556:	22 b3       	in	r18, 0x12	; 18
 558:	81 e0       	ldi	r24, 0x01	; 1
 55a:	90 e0       	ldi	r25, 0x00	; 0
 55c:	02 c0       	rjmp	.+4      	; 0x562 <DIO_write+0xce>
 55e:	88 0f       	add	r24, r24
 560:	99 1f       	adc	r25, r25
 562:	6a 95       	dec	r22
 564:	e2 f7       	brpl	.-8      	; 0x55e <DIO_write+0xca>
 566:	80 95       	com	r24
 568:	82 23       	and	r24, r18
 56a:	82 bb       	out	0x12, r24	; 18
 56c:	08 95       	ret

0000056e <int0Init>:

#include "interrupts.h"

void int0Init(void){
	//set I-bit to enable interrupts
	sei();
 56e:	78 94       	sei
	//set external int0 to rising edge trigger
	setBit(MCUCR,0);
 570:	85 b7       	in	r24, 0x35	; 53
 572:	81 60       	ori	r24, 0x01	; 1
 574:	85 bf       	out	0x35, r24	; 53
	setBit(MCUCR,1);
 576:	85 b7       	in	r24, 0x35	; 53
 578:	82 60       	ori	r24, 0x02	; 2
 57a:	85 bf       	out	0x35, r24	; 53
	//enable int0
	setBit(GICR,6);
 57c:	8b b7       	in	r24, 0x3b	; 59
 57e:	80 64       	ori	r24, 0x40	; 64
 580:	8b bf       	out	0x3b, r24	; 59
 582:	08 95       	ret

00000584 <timer0Init>:
#include "timer.h"

//setup timer0 to count 250ms each overflow
void timer0Init(void){
	//set the mode to normal mode
	clearBit(TCCR0,3);
 584:	83 b7       	in	r24, 0x33	; 51
 586:	87 7f       	andi	r24, 0xF7	; 247
 588:	83 bf       	out	0x33, r24	; 51
	clearBit(TCCR0,6);
 58a:	83 b7       	in	r24, 0x33	; 51
 58c:	8f 7b       	andi	r24, 0xBF	; 191
 58e:	83 bf       	out	0x33, r24	; 51
	//set to Fclk/1024 prescaler
	TCCR0|=5;
 590:	83 b7       	in	r24, 0x33	; 51
 592:	85 60       	ori	r24, 0x05	; 5
 594:	83 bf       	out	0x33, r24	; 51
	//set I-bit to enable global interrupt
	sei();
 596:	78 94       	sei
	//set timer0 overflow interrupt on
	setBit(TIMSK,0);
 598:	89 b7       	in	r24, 0x39	; 57
 59a:	81 60       	ori	r24, 0x01	; 1
 59c:	89 bf       	out	0x39, r24	; 57
	//reset flag
	setBit(TIFR,0);
 59e:	88 b7       	in	r24, 0x38	; 56
 5a0:	81 60       	ori	r24, 0x01	; 1
 5a2:	88 bf       	out	0x38, r24	; 56
	//set timer initial value to 0
	TCNT0 = 0x00;
 5a4:	12 be       	out	0x32, r1	; 50
 5a6:	08 95       	ret

000005a8 <_exit>:
 5a8:	f8 94       	cli

000005aa <__stop_program>:
 5aa:	ff cf       	rjmp	.-2      	; 0x5aa <__stop_program>
